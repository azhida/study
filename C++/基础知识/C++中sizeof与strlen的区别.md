## C++ sizeof 与 strlen的区别
#### 返回 [C++基础知识](../C++基础知识.md)


***


之前一直搞不清 sizeof 和 strlen 到底该怎么区分，最近查了资料：  
1、sizeof 操作符的结果类型是 size_t，它在头文件中 typedef 为 unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。  
2、sizeof 是运算符，strlen 是函数。  
3、sizeof 可以用类型做参数，strlen 只能用 char* 做参数，且必须是以 `\0` 结尾的。  
sizeof 还可以用函数做参数，比如：  
```
short f();
printf("%d\n", sizeof(f()));
```
输出的结果是 sizeof(short)，即 2。  
4、数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。  
5、大部分编译程序在编译的时候就把 sizeof 计算过了，是类型或是变量的长度，这就是 sizeof(x) 可以用来定义数组维数的原因。  
```
char str[20]="0123456789";
int a=strlen(str); // a=10;
int b=sizeof(str); // 而 b=20;
```
6、strlen 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。  
7、sizeof 后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为 sizeof 是个操作符不是个函数。  
8、当适用一个结构类型或变量时， sizeof 返回实际的大小；当适用一静态地空间数组， sizeof 归还全部数组的尺寸；sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸。  
数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址， 如：  
```
fun(char [8])
fun(char [])
```
都等价于
```
fun(char *) 
```
在 C++ 里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小。  
如果想在函数内知道数组的大小， 需要这样做：  
进入函数后用memcpy拷贝出来，长度由另一个形参传进去  
```
fun(unsiged char *p1, int len)
{
    unsigned char* buf = new unsigned char[len+1]
    memcpy(buf, p1, len);
}
```
看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚：
```
char str[20]="0123456789";
int a=strlen(str);         // a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。
int b=sizeof(str);         // 而 b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。 
```
上面是对静态数组处理的结果，如果是对指针，结果就不一样了。
```
char* ss = "0123456789";
sizeof(ss) 结果 4 ＝＝＝》ss 是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是 4。 
sizeof(*ss) 结果 1 ＝＝＝》*ss 是第一个字符 其实就是获得了字符串的第一位 '0' 所占的内存空间，是 char 类型的，占了 1 位
strlen(ss)= 10      ＝＝＝》 如果要获得这个字符串的长度，则一定要使用 strlen。strlen 用来求字符串的长度；而 sizeof 是用来求指定变量或者变量类型等所占内存大小。
```




##
#### 返回 [C++基础知识](../C++基础知识.md)