## C 变量
#### 返回 [C基础知识](../C基础知识.md) 

***


变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。  
变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：  

|类型	|描述|
|----|----|
|char|通常是一个字节（八位）, 这是一个整数类型。|
|int| 	整型，4 个字节，取值范围 -2147483648 到 2147483647。 |
| float | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 |
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数。 |
| void | 表示类型的缺失。 |

C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等。


###### C 中的变量定义
变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：
```
type variable_list;
```
在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：
```
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```
行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。  
变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：  
```
type variable_name = value;
```
下面列举几个实例：
```
extern int d = 3, f = 5;    // d 和 f 的声明与初始化
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```
不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。


###### C 中的变量声明
变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。  
变量的声明有两种情况：
- 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
- 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。
- 除非有extern关键字，否则都是变量的定义。
```
extern int i; //声明，不是定义
int i; //声明，也是定义
```

尝试下面的实例，其中，变量在头部就已经被声明，但是定义与初始化在主函数内：  
实例:
```
#include <stdio.h>

// 函数外定义变量 x 和 y
int x;
int y;
int addtwonum()
{
    // 函数内声明变量 x 和 y 为外部变量
    extern int x;
    extern int y;
    // 给外部变量（全局变量）x 和 y 赋值
    x = 1;
    y = 2;
    return x+y;
}

int main()
{
    int result;
    // 调用函数 addtwonum
    result = addtwonum();
    
    printf("result 为: %d",result);
    return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
result 为: 3
```

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。  
> addtwonum.c 文件代码：
> ```
> #include <stdio.h>
> /*外部变量声明*/
> extern int x ;
> extern int y ;
> int addtwonum()
> {
>    return x+y;
> }
> ```

> test.c 文件代码：
> ```
> #include <stdio.h>
> 
> /*定义两个全局变量*/
> int x=1;
> int y=2;
> int addtwonum();
> int main(void)
> {
>     int result;
>     result = addtwonum();
>     printf("result 为: %d\n",result);
>     return 0;
> }
> ```
当上面的代码被编译和执行时，它会产生下列结果：
```
$ gcc addtwonum.c test.c -o main
$ ./main
result 为: 3
```


###### C 中的左值（Lvalues）和右值（Rvalues）
C 中有两种类型的表达式：
- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：
```
int g = 20;
```
但是下面这个就不是一个有效的语句，会生成编译时错误：
```
10 = 20;
```



## 读者笔记


***


```
extern int a;     // 声明一个全局变量 a

int a;            // 定义一个全局变量 a

extern int a =0;  // 定义一个全局变量 a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间

int a =0;         //定义一个全局变量 a，并给初值
```
声明之后你不能直接使用这个变量，需要定义之后才能使用。  
第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。  
糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而那个 extern int a 可以出现很多次。  
当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。


***


总结：
- 1、当需要保存数据的时候，需要lvalues。
- 2、当需要读取数据的时候，需要rvalues。

lvalues 和 rvalues 角色的相互转换
1. 根据表达式的上下文情况，lvalues 在需要 rvalues 的地方会自动转换为 rvalues。例如:
   ```
   int n;
   
   int m;
   
   m = n+2; // 这个表达式里 n 是 rvalues
   ```
2. rvalues 永远不能转换为 lvalues


***


**变量的内存寻址(与系统有关)**

(1)内存寻址由大到小，优先分配内存地址比较大的字节给变量，所以说变量越先定义，内存地址就越大。 如下面代码，先定义变量 a,再定义变量 b,打印出 a 的地址是 0x7fff5fbff828,b 的值是 0x7fff5fbff824。a 的地址比 b 的地址大 4 字节。  
(2)变量地址的获取方式：& 变量名。  
(3)输出地址的方式：%p。
```
#include <stdio.h>  

int main()
{
    int a;  
    int b;
    
    printf("a的地址是%p\nb的地址是%p\n",&a,&b);
    return 0;  
}
```
(4)一个变量一定要先初始化才可以使用，因为 c 语言中默认一个没有初始化的变量值是一个不可知的很大值。如下面所示，a 没有初始化，打印出 a 的值是 1606422582。  
```
#include <stdio.h>  

int main()   
{
    int a;
    
    printf("a的值是%d\n",a);
    return 0;
}  
```

**Ethan,zhouyanchun16@163.com 的说明**  
第一点和第四点有些小伙伴运行结果可能有差异：  
**环境说明：**
- OS：Ubuntu 16.10
- gcc：6.2.0

实际执行结果发现，内存寻址由小到大,越先定义的值，内存地址越小。变量如果没有初始化，默认输出为 0。

***


在 C 语言标准(C89)没有定义布尔类型，所以 C 语言判断真假时以 0 为假，非 0 为真。所以我们通常使用逻辑变量的做法：  
```
//定义一个int类型变量，当变量值为0时表示false，值为1时表示true
int flag;
flag = 0;
//......
flag = 1;

if( flag )
{
//......
}
```
但这种做法不直观，而且没有明确 flag 一定是布尔值。所以我们又借助 C 语言的宏定义：
```
//宏定义布尔类型
#define BOOL int
#define TRUE 1
#define FALSE 0

//定义一个布尔变量
BOOL flag = FALSE;
```
这种方法虽然直观，但依然是换汤不换药，变量 flag 在编译器看来依然是 int 类型。  
新版本总会改进一些不好的地方，所以在最新的 C 语言标准(C99)解决了布尔类型的问题。C99 提供了 _Bool 型，所以布尔类型可以声明为 _Bool flag。  
_Bool 依然仍是整数类型，但与一般整型不同的是，_Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。  
C99还提供了一个头文件 <stdbool.h> 定义了 bool 代表 _Bool，true 代表 1，false 代表 0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。  
```
//导入 stdbool.h 来使用布尔类型
#include <stdbool.h>
#include <stdio.h>

//计算n!,n的值在main中定义
int main(void)
{
    int n = 10;    //计算叠乘数
    int sum = 1; //用来存放叠乘的结果
    bool flag = false;    //叠乘标记
    
    int num = n;    //循环次数
    while( !flag )
    {
        sum = sum * (num--);
        //当num=1时结束循环
        if( num == 1)
        {
            flag = true;
        }
    }
    printf ("%d的叠乘值为 %d \n", n, sum);
    return 0;
}
```


***


**全局变量和局部变量在内存中的区别**

全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。  
C语言经过编译之后将内存分为以下几个区域：
- （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。
- （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。
- （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。
- （4）文字常量区：存放常量字符串。程序结束后由系统释放。
- （5）程序代码区：存放程序的二进制代码。

显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。

有兴趣的读者可以运行下面的程序，分析一下运行结果。
```
#include <stdio.h>
#include <stdlib.h>
int k1 = 1;
int k2;
static int k3 = 2;
static int k4;
int main( )
{  staticint m1=2, m2;
    inti=1;
    char*p;
    charstr[10] = "hello";
    char*q = "hello";
    p= (char *)malloc( 100 );
    free(p);
    printf("栈区-变量地址  i：%p\n", &i);
    printf("                p：%p\n", &p);
    printf("              str：%p\n", str);
    printf("                q：%p\n", &q);
    printf("堆区地址-动态申请：%p\n", p);
    printf("全局外部有初值 k1：%p\n", &k1);
    printf("    外部无初值 k2：%p\n", &k2);
    printf("静态外部有初值 k3：%p\n", &k3);
    printf("    外静无初值 k4：%p\n", &k4);
    printf("  内静态有初值 m1：%p\n", &m1);
    printf("  内静态无初值 m2：%p\n", &m2);
    printf("文字常量地址    ：%p, %s\n",q, q);
    printf("程序区地址      ：%p\n",&main);
    return0;
}
```


***


变量应先定义再赋值，在一个表达式中，左值必须是变量，右值可以是变量，常量或者表达式。
```
#include<stdio.h>

int main()
{
    int a,b;
    a=(b=3);//注意左值 等同a=b=3,但是a=(a=b)=3是错误表示
    printf("%d\n",a);
    return 0;
}
```


***


变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。  
变量声明：用于向程序表明变量的类型和名字。  
定义也是声明，extern 声明不是定义。  
定义也是声明：当定义变量时我们声明了它的类型和名字。  
extern 声明不是定义：通过使用 extern 关键字声明变量名而不定义它。

**[注意]**  
变量在使用前就要被定义或者声明。  
在一个程序中，变量只能定义一次，却可以声明多次。  
定义分配存储空间，而声明不会。


***


#### 返回 [C基础知识](../C基础知识.md)