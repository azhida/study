## C 运算符
#### 返回 [C基础知识](../C基础知识.md) 

***


运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：
- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符


###### 算术运算符
下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：

|  运算符	|描述	|实例  |
|  ---	|---	| ---  |
|  +	| 把两个操作数相加	| A + B 将得到 30  |
|  -	| 从第一个操作数中减去第二个操作数	| A - B 将得到 -10  |
|  *	| 把两个操作数相乘	| A * B 将得到 200 |
|  /	| 分子除以分母	| 	B / A 将得到 2 |
|  %	| 取模运算符，整除后的余数	| 	B % A 将得到 0 |
|  ++	| 自增运算符，整数值增加 1	| 	A++ 将得到 11 |
|  --	| 自减运算符，整数值减少 1	| 	A-- 将得到 9 |

请看下面的实例，了解 C 语言中所有可用的算术运算符：
```
#include <stdio.h>
 
int main()
{
   int a = 21;
   int b = 10;
   int c ;
 
   c = a + b;
   printf("Line 1 - c 的值是 %d\n", c );
   c = a - b;
   printf("Line 2 - c 的值是 %d\n", c );
   c = a * b;
   printf("Line 3 - c 的值是 %d\n", c );
   c = a / b;
   printf("Line 4 - c 的值是 %d\n", c );
   c = a % b;
   printf("Line 5 - c 的值是 %d\n", c );
   c = a++;  // 赋值后再加 1 ，c 为 21，a 为 22
   printf("Line 6 - c 的值是 %d\n", c );
   c = a--;  // 赋值后再减 1 ，c 为 22 ，a 为 21
   printf("Line 7 - c 的值是 %d\n", c );
 
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - c 的值是 31
Line 2 - c 的值是 11
Line 3 - c 的值是 210
Line 4 - c 的值是 2
Line 5 - c 的值是 1
Line 6 - c 的值是 21
Line 7 - c 的值是 22
```

以下实例演示了 a++ 与 ++a 的区别：
```
#include <stdio.h>
 
int main()
{
   int c;
   int a = 10;
   c = a++; 
   printf("先赋值后运算：\n");
   printf("Line 1 - c 的值是 %d\n", c );
   printf("Line 2 - a 的值是 %d\n", a );
   a = 10;
   c = a--; 
   printf("Line 3 - c 的值是 %d\n", c );
   printf("Line 4 - a 的值是 %d\n", a );
 
   printf("先运算后赋值：\n");
   a = 10;
   c = ++a; 
   printf("Line 5 - c 的值是 %d\n", c );
   printf("Line 6 - a 的值是 %d\n", a );
   a = 10;
   c = --a; 
   printf("Line 7 - c 的值是 %d\n", c );
   printf("Line 8 - a 的值是 %d\n", a );
 
}
```
以上程序执行输出结果为：
```
先赋值后运算：
Line 1 - c 的值是 10
Line 2 - a 的值是 11
Line 3 - c 的值是 10
Line 4 - a 的值是 9
先运算后赋值：
Line 5 - c 的值是 11
Line 6 - a 的值是 11
Line 7 - c 的值是 9
Line 8 - a 的值是 9
```


###### 关系运算符
下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：

| 运算符 |	描述|	实例 |
| --- |	:--- |	:--- |
| == |	检查两个操作数的值是否相等，如果相等则条件为真。 |	(A == B) 为假。 |
| != |	检查两个操作数的值是否相等，如果不相等则条件为真。 |	(A != B) 为真。 |
| > |	检查左操作数的值是否大于右操作数的值，如果是则条件为真。 |(A > B) 为假。 |
| < |	检查左操作数的值是否小于右操作数的值，如果是则条件为真。 |	(A < B) 为真。 |
| >= |	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 |	(A >= B) 为假。 |
| <= |	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 |	(A <= B) 为真。 |

请看下面的实例，了解 C 语言中所有可用的关系运算符：
```
#include <stdio.h>
 
int main()
{
   int a = 21;
   int b = 10;
   int c ;
 
   if( a == b )
   {
      printf("Line 1 - a 等于 b\n" );
   }
   else
   {
      printf("Line 1 - a 不等于 b\n" );
   }
   if ( a < b )
   {
      printf("Line 2 - a 小于 b\n" );
   }
   else
   {
      printf("Line 2 - a 不小于 b\n" );
   }
   if ( a > b )
   {
      printf("Line 3 - a 大于 b\n" );
   }
   else
   {
      printf("Line 3 - a 不大于 b\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 5;
   b = 20;
   if ( a <= b )
   {
      printf("Line 4 - a 小于或等于 b\n" );
   }
   if ( b >= a )
   {
      printf("Line 5 - b 大于或等于 a\n" );
   }
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - a 不等于 b
Line 2 - a 不小于 b
Line 3 - a 大于 b
Line 4 - a 小于或等于 b
Line 5 - b 大于或等于 a
```


###### 逻辑运算符
下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述 | 实例 |
| --- | --- | --- |
| && | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 | (A && B) 为假。 |
| &vert;&vert; | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A &vert;&vert; B) 为真。 |
| ! | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。 |

请看下面的实例，了解 C 语言中所有可用的逻辑运算符：
```
#include <stdio.h>
 
int main()
{
   int a = 5;
   int b = 20;
   int c ;
 
   if ( a && b )
   {
      printf("Line 1 - 条件为真\n" );
   }
   if ( a || b )
   {
      printf("Line 2 - 条件为真\n" );
   }
   /* 改变 a 和 b 的值 */
   a = 0;
   b = 10;
   if ( a && b )
   {
      printf("Line 3 - 条件为真\n" );
   }
   else
   {
      printf("Line 3 - 条件为假\n" );
   }
   if ( !(a && b) )
   {
      printf("Line 4 - 条件为真\n" );
   }
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - 条件为真
Line 2 - 条件为真
Line 3 - 条件为假
Line 4 - 条件为真
```


###### 位运算符
位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p | q | 	p & q | p &vert; q | 	p ^ q |
| --- | --- | 	--- | --- | --- |
| 0 | 0 | 	0 | 0 | 0 |
| 0 | 1 | 	0 | 1 | 1 |
| 1 | 1 | 	1 | 1 | 0 |
| 1 | 0 | 	0 | 1 | 1 |

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：
> A = 0011 1100  
> B = 0000 1101  
> ......  
> A&B = 0000 1100  
> A|B = 0011 1101  
> A^B = 0011 0001  
> ~A  = 1100 0011  
> 

下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：

<table>
<thead>
<tr><th>运算符</th><th>描述</th><th>实例</th></tr>
</thead>
<tbody>

<tr>
<td>&</td>
<td>
按位与操作，按二进制位进行"与"运算。运算规则：

```
0&0=0;   
0&1=0;    
1&0=0;     
1&1=1;
```

</td>
<td> (A & B) 将得到 12，即为 0000 1100 </td>
</tr>

<tr>
<td>|</td>
<td>
按位或运算符，按二进制位进行"或"运算。运算规则：

```
0|0=0;   
0|1=1;   
1|0=1;    
1|1=1;
```

</td>
<td> (A | B) 将得到 61，即为 0011 1101 </td>
</tr>

<tr>
<td> ^ </td>
<td>
异或运算符，按二进制位进行"异或"运算。运算规则：

```
0^0=0;   
0^1=1;   
1^0=1;  
1^1=0;
```

</td>
<td> (A ^ B) 将得到 49，即为 0011 0001 </td>
</tr>

<tr>
<td> ~ </td>
<td>
取反运算符，按二进制位进行"取反"运算。运算规则：

```
~1=-2;   
~0=-1;
```

</td>
<td> (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 </td>
</tr>

<tr>
<td> << </td>
<td>
二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。
</td>
<td> A << 2 将得到 240，即为 1111 0000 </td>
</tr>

<tr>
<td> >> </td>
<td>
二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。
</td>
<td> A >> 2 将得到 15，即为 0000 1111 </td>
</tr>

</tbody>
</table>

请看下面的实例，了解 C 语言中所有可用的位运算符：
```
#include <stdio.h>
 
int main()
{
 
   unsigned int a = 60;    /* 60 = 0011 1100 */  
   unsigned int b = 13;    /* 13 = 0000 1101 */
   int c = 0;           
 
   c = a & b;       /* 12 = 0000 1100 */ 
   printf("Line 1 - c 的值是 %d\n", c );
 
   c = a | b;       /* 61 = 0011 1101 */
   printf("Line 2 - c 的值是 %d\n", c );
 
   c = a ^ b;       /* 49 = 0011 0001 */
   printf("Line 3 - c 的值是 %d\n", c );
 
   c = ~a;          /*-61 = 1100 0011 */
   printf("Line 4 - c 的值是 %d\n", c );
 
   c = a << 2;     /* 240 = 1111 0000 */
   printf("Line 5 - c 的值是 %d\n", c );
 
   c = a >> 2;     /* 15 = 0000 1111 */
   printf("Line 6 - c 的值是 %d\n", c );
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - c 的值是 12
Line 2 - c 的值是 61
Line 3 - c 的值是 49
Line 4 - c 的值是 -61
Line 5 - c 的值是 240
Line 6 - c 的值是 15
```


###### 赋值运算符
下表列出了 C 语言支持的赋值运算符：

| 运算符 |	描述|	实例 |
| --- |	---|	--- |
| = |	简单的赋值运算符，把右边操作数的值赋给左边操作数|	C = A + B 将把 A + B 的值赋给 C |
| += |	加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 |	C += A 相当于 C = C + A |
| -= |	减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 |	C -= A 相当于 C = C - A |
| *= |	乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 |		C *= A 相当于 C = C * A |
| /= |	除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 |	C /= A 相当于 C = C / A |
| %= |	求模且赋值运算符，求两个操作数的模赋值给左边操作数 |		C %= A 相当于 C = C % A |
| <<= |	左移且赋值运算符 |	C <<= 2 等同于 C = C << 2 |
| >>= |	右移且赋值运算符 |	C >>= 2 等同于 C = C >> 2 |
| &= |	按位与且赋值运算符 | C &= 2 等同于 C = C & 2 |
| ^= |	按位异或且赋值运算符 | C ^= 2 等同于 C = C ^ 2 |
| &vert;= |	按位或且赋值运算符 | C &vert;= 2 等同于 C = C &vert; 2 |

请看下面的实例，了解 C 语言中所有可用的赋值运算符：
```
#include <stdio.h>
 
int main()
{
   int a = 21;
   int c ;
 
   c =  a;
   printf("Line 1 - =  运算符实例，c 的值 = %d\n", c );
 
   c +=  a;
   printf("Line 2 - += 运算符实例，c 的值 = %d\n", c );
 
   c -=  a;
   printf("Line 3 - -= 运算符实例，c 的值 = %d\n", c );
 
   c *=  a;
   printf("Line 4 - *= 运算符实例，c 的值 = %d\n", c );
 
   c /=  a;
   printf("Line 5 - /= 运算符实例，c 的值 = %d\n", c );
 
   c  = 200;
   c %=  a;
   printf("Line 6 - %%= 运算符实例，c 的值 = %d\n", c );
 
   c <<=  2;
   printf("Line 7 - <<= 运算符实例，c 的值 = %d\n", c );
 
   c >>=  2;
   printf("Line 8 - >>= 运算符实例，c 的值 = %d\n", c );
 
   c &=  2;
   printf("Line 9 - &= 运算符实例，c 的值 = %d\n", c );
 
   c ^=  2;
   printf("Line 10 - ^= 运算符实例，c 的值 = %d\n", c );
 
   c |=  2;
   printf("Line 11 - |= 运算符实例，c 的值 = %d\n", c );
 
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - =  运算符实例，c 的值 = 21
Line 2 - += 运算符实例，c 的值 = 42
Line 3 - -= 运算符实例，c 的值 = 21
Line 4 - *= 运算符实例，c 的值 = 441
Line 5 - /= 运算符实例，c 的值 = 21
Line 6 - %= 运算符实例，c 的值 = 11
Line 7 - <<= 运算符实例，c 的值 = 44
Line 8 - >>= 运算符实例，c 的值 = 11
Line 9 - &= 运算符实例，c 的值 = 2
Line 10 - ^= 运算符实例，c 的值 = 0
Line 11 - |= 运算符实例，c 的值 = 2
```


###### 杂项运算符 ↦ sizeof & 三元
下表列出了 C 语言支持的其他一些重要的运算符，包括 `sizeof` 和 `?:`。

|运算符|	描述|	实例|
| --- |	--- |	--- |
| sizeof() |		返回变量的大小。 |		sizeof(a) 将返回 4，其中 a 是整数。 |
| & |	返回变量的地址。 |	&a; 将给出变量的实际地址。 |
| * | 指向一个变量。 |	*a; 将指向一个变量。 |
| ?: | 条件表达式 |		如果条件为真 ? 则值为 X : 否则值为 Y |

请看下面的实例，了解 C 语言中所有可用的杂项运算符：
```
#include <stdio.h>
 
int main()
{
   int a = 4;
   short b;
   double c;
   int* ptr;
 
   /* sizeof 运算符实例 */
   printf("Line 1 - 变量 a 的大小 = %lu\n", sizeof(a) );
   printf("Line 2 - 变量 b 的大小 = %lu\n", sizeof(b) );
   printf("Line 3 - 变量 c 的大小 = %lu\n", sizeof(c) );
 
   /* & 和 * 运算符实例 */
   ptr = &a;    /* 'ptr' 现在包含 'a' 的地址 */
   printf("a 的值是 %d\n", a);
   printf("*ptr 是 %d\n", *ptr);
 
   /* 三元运算符实例 */
   a = 10;
   b = (a == 1) ? 20: 30;
   printf( "b 的值是 %d\n", b );
 
   b = (a == 10) ? 20: 30;
   printf( "b 的值是 %d\n", b );
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Line 1 - 变量 a 的大小 = 4
Line 2 - 变量 b 的大小 = 2
Line 3 - 变量 c 的大小 = 8
a 的值是 4
*ptr 是 4
b 的值是 30
b 的值是 20
```


###### C 中的运算符优先级
运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。  
例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。  
下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。  

| 类别| 	运算符| 	结合性 |
| --- | --- | --- |
| 后缀  | () [] -> . ++ - -   | 	从左到右  |
| 一元   | + - ! ~ ++ - - (type)* & sizeof   | 	从右到左   |
| 乘除    | * / %   | 	从左到右    |
| 加减     | +-   | 	从左到右    |
| 移位     | << >>    | 	从左到右    |
| 关系      | < <= > >=     | 	从左到右    |
| 相等       | == != | 	从左到右    |
| 位与 AND | &  | 	从左到右    |
| 位异或 XOR  | ^   | 	从左到右    |
| 位或 OR  | &vert;  | 	从左到右    |
| 逻辑与 AND   |&&  | 	从左到右    |
| 逻辑或 OR    | &vert;&vert;  | 	从左到右    |
| 条件 | ?: | 从右到左  |
| 赋值  | = += -= *= /= %=>>= <<= &= ^= &vert;=  | 从右到左  |
| 逗号  | ,  | 从左到右 |

请看下面的实例，了解 C 语言中运算符的优先级：
```
#include <stdio.h>
 
main()
{
   int a = 20;
   int b = 10;
   int c = 15;
   int d = 5;
   int e;
 
   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   printf("(a + b) * c / d 的值是 %d\n",  e );
 
   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   printf("((a + b) * c) / d 的值是 %d\n" ,  e );
 
   e = (a + b) * (c / d);   // (30) * (15/5)
   printf("(a + b) * (c / d) 的值是 %d\n",  e );
 
   e = a + (b * c) / d;     //  20 + (150/5)
   printf("a + (b * c) / d 的值是 %d\n" ,  e );
  
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
(a + b) * c / d 的值是 90
((a + b) * c) / d 的值是 90
(a + b) * (c / d) 的值是 90
a + (b * c) / d 的值是 50
```



## 读者笔记


***


利用异或 ^ 来交换两个数的值，而且不引入其他变量。  

```
unsigned int a=60;  //0011 1100
unsigned int b=13;  //0000 1101
a=a^b;              //a=a^b=0011 0001
b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b
a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)
```
实例
```
#include<stdio.h>

int main( )
{
    unsigned int a=60;         //0011 1100
    unsigned int b=13;         //0000 1101
    printf("a=%d,b=%d",a,b);   //输出a，b的值
    printf("\n");
    a=a^b;                     //a=a^b=0011 0001
    b=a^b;                     //b=a^b=0011 1100
    a=a^b;                     //a=a^b=0000 1101
    printf("a=%d,b=%d",a,b);   //输出a，b的值
}
```
结果：
```
a=60，b=13；
a=13，b=60;
```
仅用一行代码实现的方法:
```
a^=b^=a^=b;
```
其等价于:
```
a=a^b;
b=a^b;
a=a^b;
```
当然，这种利用位运算的交换方法只适用于整型变量，不能用于浮点型变量!


***


利用位与 & 运算，判断一个整数是否是2的整数次幂。
二进制数的位权是以2为底的幂，如果一个整数 m 是 2 的 n 次幂，那么转换为二进制之后只有最高位为 1，其余位置为 0，再观察 m-1 转换为二进制后的形式以及 m&(m-1) 的结果，例如：  
```
2 --> 0000 0010        1 --> 0000 0001        2&1 --> 0000 0010 & 0000 0001 = 0
4 --> 0000 0100        3 --> 0000 0011        4&3 --> 0000 0100 & 0000 0011 = 0
8 --> 0000 1000        7 --> 0000 0111        8&7 --> 0000 1000 & 0000 0111 = 0
```
可以看出所有的 1 完美的错过了，根据位与的特点可知 m&(m-1) 的结果为 0。  
如果整数 m 不是 2 的 n 次幂，结果会怎样呢？例如 m=9 时：
```
9 --> 0000 1001        8 --> 0000 1000        9&8 --> 0000 1001 & 0000 1000 != 0
```
利用这一特点，即可判断一个整数是否是2的整数次幂。  
示例：
```
int func(int num)
{
    return ((num > 0) && ((num & (num - 1)) == 0));//2的n次幂大于0
}
```
返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。


***


**对取余运算的说明**  

取余，也就是求余数，使用的运算符是 %。C 语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。  
另外，余数可以是正数也可以是负数，由 % 左边的整数决定：
- 如果 % 左边是正数，那么余数也是正数；
- 如果 % 左边是负数，那么余数也是负数；

请看下面的例子：
```
#include <stdio.h>

int main()
{
    printf( "100%%12=%d \n100%%-12=%d \n-100%%12=%d \n-100%%-12=%d \n", 100%12, 100%-12, -100%12, -100%-12 );
    return 0;
}
```
运行结果：
```
100%12=4
100%-12=4
-100%12=-4
-100%-12=-4 
```


***


对于 2 的幂指数的详细程序
```
#include <stdio.h>

int num;
int func(int num)
{
    if ((num>0)&&(num&(num-1))==0)
    {
        printf("%d是2的整数次幂",num);
    }
    else
    {
        printf("%d不是2的整数次幂",num);
    }
    return((num>0)&&(num&(num-1))==0);
}

int main()
{
    printf("请输入要查询的数\n");
    scanf("%d",&num);
    func(num);
}
```


***


**不同长度的数据进行位运算**  

如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。  
以“与”运算为例说明如下：我们知道在 C 语言中 long 型占 4 个字节，int 型占 2 个字节，如果一个 long 型数据与一个 int 型数据进行“与”运算，右端对齐后，左边不足的位依下面三种情况补足:  
- （1）如果整型数据为正数，左边补 16 个 0。
- （2）如果整型数据为负数，左边补 16 个 1。
- （3）如果整形数据为无符号数，左边也补 16 个 0。

如：`long a=123;int b=1;` 计算 `a & b`。  
如：`long a=123;int b=-1;` 计算 `a & b`。  
如：`long a=123; unsigned int b=1;` 计算 `a & b`。


***


**| 和 ||，& 和 && 的区别**

我们将 `||` 和 `&&` 定义为逻辑运算符，而 `|` 和 `&` 定义为位运算符。  
`&&` 如果两个操作数都非零，则条件为真；  
`||` 如果两个操作数中有任意一个非零，则条件为真。  
`&` 按位与操作，按二进制位进行"与"运算。运算规则：（有 0 则为 0）
```
0&0=0;   
0&1=0;    
1&0=0;     
1&1=1;
```
`|` 按位或运算符，按二进制位进行"或"运算。运算规则：（有 1 则为 1）
```
0|0=0;   
0|1=1;   
1|0=1;    
1|1=1;
```

**那么，问题来了，在判断语句中，用 | 还是 ||，& 还是 &&？**  
判断语句中为布尔类型，值只有 true 和 false（如果变量值为 0 就是 false，否则为 true）
```
举个例子，a=1 b=2
所以 a>0 这个值为true    b>1 这个值为true     b>2 这个值为 false
如 if(a>0&b>1)  我们可以得出 if(true&true)，条件成立（true不为0，所以true&true不为0）
如 if(a>0&&b>1)  我们可以得出 if(true&&true),条件成立（&&两边操作数都非零，所以条件成立）
如 if(b>2&a>0) 我们可以得出 if(false&true)，条件不成立（false为0，false&true为0，条件不成立）
如 if(b>2&&a>0) 我们可以得出 if(false&&a>0)，条件不成立（&&左侧为false，&&运算到此结束，条件不成立）
```
可以看出 & 和 && 在判断语句中都可以实现“和”这个功能，不过区别在于 & 两边都运算，而 && 先算 && 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 &&（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？）  
而 | 和 || 的比较与上类似，不做赘述。


***


**a++ 与 ++a 区别在于一个后加，一个先加。**

a++ 输出 a 的值再自加，缓存 a 自加后的结果，用于下次进行与 a 相关的计算。  
++a 则相当于 a+1。  
```
#include <stdio.h>

int main(int argc, char **argv) {
    int a=100;
    int b=50;
//    b++;
    printf("%d,%d\n",a++,++a);
    printf("%d,%d",b++,++b);
    return 0;
}
```
运行后输出：
```
101,102
51,52
```
若不注释 b++：
```
int main(int argc, char **argv) {
    int a=100;
    int b=50;
    b++;
    printf("%d,%d\n",a++,++a);
    printf("%d,%d",b++,++b);
    return 0;
}
```
则结果为：
```
101,102
52,53
```


***


运算符优先级：
```
括号成员是老大;      // 括号运算符 []() 成员运算符.  ->
全体单目排老二;      // 所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&
乘除余三,加减四;    // 这个"余"是指取余运算即%
移位五，关系六;     // 移位运算符：<< >> ，关系：> < >= <= 等
等与不等排行七;     // 即 == 和 !=
位与异或和位或;     // 这几个都是位运算: 位与(&)异或(^)位或(|)    
"三分天下"八九十;  
逻辑与，逻辑或;    // 逻辑运算符: || 和 &&
十一十二紧挨着;    // 注意顺序: 优先级(||)  底于 优先级(&&) 
条件只比赋值高,    // 三目运算符优先级排到 13 位只比赋值运算符和 "," 高
逗号运算最低级!    //逗号运算符优先级最低 
```


***


一句话系列。  
逻辑是将两个操作值转换成Boolean进行操作。  
逻辑与：双真真（双真为真，下同）；  
逻辑或：单真真；  
逻辑非：取反；  
**没有说明的情况都为假（0）。**  
按位是将两个操作值转换成二进制然后**逐位**进行操作。  
按位与：双真真；  
按位或：有真真（有一个真即为真，两个真的情况也属于有一个真）；  
按位异或：单真真（区别于有真真，两个真的情况不属于单真）；  
**按位是二进制逐位操作，未说明的皆假。**


***


c语言中运算符优先级的总结：  
**初等运算符>单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符**  
```
初等运算符有：（）、[ ]、->、.  (后两者均为结构体成员运算符)；
单目运算符有：！、~、++、--、sizeof、&、*；
算术运算符有：*、/、+、-、<<、>>;
关系运算符有：<、<=、>、>=、==、!=、&、^、|；(此栏排列仍有优先级顺序哦);
逻辑运算符有：&&、||；
条件运算符有：?:（即三目运算符）;
赋值运算符有：=、+=、-=、*=、/=、%=、>>=、<<=；等
```
另外，单目运算符的优先级都高于双目运算符。


***


在计算机中，负数以其正值的补码形式表达  
什么叫补码呢？这得从原码，反码说起。  
**原码**：一个整数，按照绝对值大小转换成的二进制数，称为原码。  
比如 `00000000 00000000 00000000 00000101` 是 5 的原码。  
**反码**：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。  
取反操作指：原为 1，得 0；原为 0，得 1。（1 变 0; 0 变 1）  
比如：将 00000000 00000000 00000000 00000101 每一位取反，得 11111111 11111111 11111111 11111010。  
称：11111111 11111111 11111111 11111010是 00000000 00000000 00000000 00000101 的反码。  
反码是相互的，所以也可称：11111111 11111111 11111111 11111010 和00000000 00000000 00000000 00000101 互为反码。  
**补码**：反码加1称为补码。  
也就是说，要得到一个数的补码，先得到反码，然后将反码加上 1，所得数称为补码。  
比如：00000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。  
那么，补码为：  
11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011  
所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。  


***


#### 返回 [C基础知识](../C基础知识.md)