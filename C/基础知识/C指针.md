## C 指针
#### 返回 [C基础知识](../C基础知识.md) 

***


学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。  
正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 `&` 运算符访问的地址，它表示了在内存中的一个地址。  
请看下面的实例，它将输出定义的变量地址：
```
#include <stdio.h>
 
int main ()
{
    int var_runoob = 10;
    int *p;              // 定义指针变量
    p = &var_runoob;
 
   printf("var_runoob 变量的地址： %p\n", p);
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
var_runoob 变量的地址： 0x7ffeeaae08d8
```
![]( https://www.runoob.com/wp-content/uploads/2014/09/c-pointer.png )  
通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。


###### 什么是指针？
指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：
```
type *var-name;
```
在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 `*` 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：  
```
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```
所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。  
不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。


###### 如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 `*` 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：  
```
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20
```


###### C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。  
NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：
```
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
ptr 的地址是 0x0
```
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。  
如需检查一个空指针，您可以使用 if 语句，如下所示：
```
if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
```


###### C 指针详解
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：

| 概念 | 描述 |
| --- | --- |
| [指针的算术运算]( https://www.runoob.com/cprogramming/c-pointer-arithmetic.html ) | 可以对指针进行四种算术运算：++、--、+、- |
| [指针数组]( https://www.runoob.com/cprogramming/c-array-of-pointers.html ) | 可以定义用来存储指针的数组。 |
| [指向指针的指针]( https://www.runoob.com/cprogramming/c-pointer-to-pointer.html ) | C 允许指向指针的指针。 |
| [传递指针给函数]( https://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html ) | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 |
| [从函数返回指针]( https://www.runoob.com/cprogramming/c-return-pointer-from-functions.html ) | C 允许函数返回指针到局部变量、静态变量和动态内存分配。 |




## 读者笔记

***


指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。  
要理解指针就要先理解计算机的内存。计算机内存会被划分为按顺序编号的内存单元。每个变量都是存储在内存单元中的，称之为地址。  
```
#include <stdio.h>

int main ()
{
    int var = 20;   /* 实际变量的声明 此时的 VAR 这个变量是存在某个地址的，地址对应某个内存单元，该单元中存储了数据20 */
    int *ip;         /* 指针变量的声明 定义了一个指针 即一个内存单元的地址变量 */

    ip = &var;      /* 在指针变量中存储 var 的地址 就是将地址值赋值给指针这个变量*/

    /* 在指针变量中存储的地址 利用&符号直接输出了var所存储的数据的内存单元的地址*/
    printf("Address of var variable: %p\n", &var );
    
    /* 在指针变量中存储的地址 ip代表的是这个赋值到的地址的值 所以输出的是地址值 */
    printf("Address stored in ip variable: %p\n", ip );
    
    /* 使用指针访问值 *ip代表的是定义到这个内存单元之后，内存单元中所存储的数据的值也就是将20赋值给var中20这个值 */
    printf("Value of *ip variable: %d\n", *ip );

    return 0;
}
```


***


指针是一个变量，所以可以使用任何合法的变量名。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。  
然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。  
但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。  
所有指针在创建时都要初始化，如果不知道他指向什么就将 0 赋值给他。必须初始化指针，没有被初始化的指针被称为失控指针(野指针）。
```
#include <stdio.h>

int main ()
{
    int *p = 0;
    int a ;
    p = &a;
    printf ("输入一个数字\n");
    scanf ("%d",p);
    printf("%d\n",*p);
}
```
实例定义了变量 a 和指针变量 p。p = &a;表示指针变量指向了变量 a，p 中存放的地址为 a 的地址 &a，*p 所指的是 p 中存放的地址 a 内存单元中的值。


***


```
/*按照偏移值访问函数形参内容实验*/
//二级指针
void Pros(char* a,int b,int e,char et)
{
    char **p=&a;
    //a==*p
    printf("%p %p %p %p \n%p\n",&a,p,a,*p,&b);
    printf("%s\n",*p);
    p++;
    printf("%d\n",*p);
    p++;
    printf("%d\n",*p);
    p++;
    printf("%c\n",*p);
    return;
}

//一级指针访问
void Test(char* a,int b)
{
    char *p=(char*)&a;
    //a!=*p;
    //printf("%p %p %p %p\n",&a,p,a,*p);
    //printf("%p\n",&b);
    //得出结果一级指针自加+1 二级指针自按照元素内容大小自加
    //printf("%d %p\n",*(++p),p);
    //printf("%d %p\n",*(p+8),p+8);
    //a=a[0]一个printf函数以'\0'结束
    //此时p=&a把元素首地址给了p或者说a只记录一个元素首地址的地址
    //同等汇编语句 a：db 'Hello' b:db '16'
    //所以 p=&a != p=a ;
    /*
    char *a="Hello";
    char *b=(char*)&a;
    printf("%p %p %p %p",&a,b,a,&(a[0]));
    */
    //printf("%c %p %p\n",*a,a,&(a[0]));
    //printf("%c %p %p\n",*(a+1),a+1,&(a[1]));
    printf("%c\n",*(*(char**)p));
    //if p=a; *p=a;
    p=a;
    printf("%s",p);
    return;
}

int main()
{
    //Pros("Hello",5,66666,'a');
    Test("Hello",16);
    //指针转换问题
    /*
    char *a="Hello";//&a变量里面存储着a所指向的变量地址
    //char **p=&a;
    char *b=(char*)&a;
    char **p=&a;
    printf("%p %p %p %p\n",&a,b,a,*b);
    printf("%p %c\n",&(*a),*(&(*(a+1))));
    printf("%p %c\n",a,*a);//此时a->H，*a=H;
    printf("%p %c\n",(*p),*(*p));
    //p=&a,*p=a所指向的第一个元素的地址还需要一解才能访问正确数据
    //所以1级指针需要解2次 所以进行强制转换
    printf("%c \n",*(*(char**)b));
    //原试解 现在b=&a,*b= &a->a所以如果此时想正确访问H必须在解
    */
    return 1;
}
```


***


**指针的一些复杂说明：**  

- `int p;` -- 这是一个普通的整型变量
- `int *p;` -- 首先从 p 处开始,先与*结合,所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。
- `int p[3];` -- 首先从 p 处开始,先与[] 结合,说明 p 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。
- `int *p[3];` -- 首先从 p 处开始, 先与 [] 结合, 因为其优先级比 * 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。
- `int (*p)[3];` -- 首先从 p 处开始, 先与 * 结合,说明 p 是一个指针然后再与 [] 结合(与"()"这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与int 结合, 说明数组里的元素是整型的。所以 p 是一个指向由整型数据组成的数组的指针。
- `int **p;` -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针。
- `int p(int);` -- 从 p 处起,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据。
- `int (*p)(int);` -- 从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与()结合, 说明指针指向的是一个函数, 然后再与()里的 int 结合, 说明函数有一个int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。
- `int *(*p(int))[3];` -- 可以先跳过, 不看这个类型, 过于复杂从 p 开始,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与[]结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据。所以 p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

**更多内容参考**：[C 指针详解]( https://www.runoob.com/w3cnote/c-pointer-detail.html )


***


指针实例说明：
```
int board[8][8];    /* int 数组的数组 */ 
int ** ptr;         /* 指向 int 指针的指针 */
int * risks[10];    /* 具有 10 个元素的数组, 每个元素是一个指向 int 的指针 */
int (* rusks) [10];  /* 一个指针, 指向具有 10 个元素的 int 数组 */
int * oof[3][4];    /* 一个 3 x 4 的数组, 每个元素是一个指向 int 的指针 */ 
int (* uuf) [3][4]; /* 一个指针, 指向 3 X 4 的 int 数组 */
int (* uof[3]) [4]; /* 一个具有 3 个元素的数组, 每个元素是一个指向具有 4 个元素的int 数组的指针 */ 
```


***


**指向函数的指针**  

代码和数据是一样的，都需要占据一定内存，那当然也会有一个基地址，所以我们可以定义一个指针来指向这个基地址，这就是所谓的函数指针。  
假设有函数：
```
double func(int a,char c);
double (*p)(int a,char c);
p=&func;
```
即可以定义一个函数指针。  
**调用函数**  
```
double s1=func(100,'x');
double s2=(*p)(100,'x');
```
上面两个语句是等价的。


***


函数指针形式的传递，实质却是地址传递的一个例子：  
```
#include <stdio.h>

void func1(int *a, int **b);

void func1(int *a, int **b)
{
   (*a)++;
   (*b)++;//这里虽然传进来的是指针的形式，但其实是指针c的地址，
          //可以认为这里本质还是值传递，只不过这个值是地址值
}

int main()
{
    int a[2] = {10, 20};
    int *b = &a[0];
    int *c = a+1;
    int **d = &c;
    
    func1(b, d);
    printf("a[0] = %d   a[1] = %d\n", a[0], a[1]);

    return 0;
}
```
执行结果：`a[0] = 11 a[1] = 20`  
由上可知，虽然传递参数时，是以指针形式进行的，但有时候会发现其实还是值传递，是地址值的传递，特别是在多维数组进行参数传递的时候，特别容易出现这种情况。


***


为什么叫指针，指针其实是一种很形象的比喻，下面说说我的个人理解。  
int 变量存的是 int 型的值，char 变量存的是 char 型的值，而指针，它是一种特殊的变量，存的是内存地址，按照这个模板可以把它理解为：**“内存地址变量” 存的是 “内存地址”，等价于：“指针变量” 存的是 “内存地址”** 。  
操作系统进行资源调度时，会根据这些变量存的地址去请求和使用那个地址代表的内存区域，这就仿佛像是这个变量存的地址指向了某片内存，人们用 “指针” 来统称所谓的 “内存地址变量”。  
因此，**任何跟指针有关的概念，都可以联系内存地址加以理解**，二者必然有联系，数组与指针，函数与指针，都是如此。
- **内存是线性的**，内存以地址空间的形式呈现给我们看的，所以可以说所谓的地址空间也是线性的，指针存放的是内存地址，所以你可以对地址做 ++，或者 -- 这样的运算。
- **两个指针不赋 NULL，是坏习惯**
- **初始化指针不赋 NULL**，因为这样的指针会指向一片未知的区域，这样的指针不是空指针，但指向一片访问受限制的内存区域，你无法使用它，这样的情况下的指针，业界给了它一个形象的名字：“野指针”，而且难以调试，在许多编译器单步 debug 会出现奇怪的错误，但经常看见的 "Segmentation Fault" 这样的错误，实测当代码多的时候，这是一个非常蛋疼的错误，野指针就是成因之一，所以看到这样的错误，首先是想想，是否有某些指针没有初始化引起的
- **free() 后指针不赋 NULL**，为指针分配内存后，指针便可以指向一片合法可使用的内存，但使用 free() 释放那片内存时，指针依旧存放着那片内存的地址，也就是依旧指向那片内存，但这片内存已经释放，不可访问，这时若不小心使用了这个指针，便会内存错误，又是会有奇怪的 bug ，代码几百行多点就会难以调试，业界给这样的指针也有个统称：“悬空指针”，为了避免这种蛋疼的情况出现，一定要释放内存后，给指向这片内存的指针，都赋值为 NULL，从中也可以看出，free() 这个函数释放内存时跟指向这片内存的指针并没有什么卵关系，不会连着把指针一起搞定掉的！ **珍爱生命，远离 "野指针" 与 "悬空指针" ！**
- **多级指针**，指向指针的指针，有时人们也管它叫多维指针。既然指针变量是一个变量，指针变量能存变量的内存的地址。  
  像 int * 存 int 型变量的地址，char * 存 char 型的地址，那指针理所当然可以存指针变量的地址啊。
  例如，int ** 存 int * 的地址，int *** 存 int ** 的地址。  
  这就是一个二级指针存一级指针的地址，三级指针存二级指针的地址，人们把这样的过程叫指向指针的指针，但其实也就是一个上一级的指针存了下一级的指针的地址而已。  
  因此，像上面说的，你存了它的地址，你就是指向它，所以：  
  - 二级指针存一级指针的地址，那么可以说二级指针指向一级指针
  - 三级指针存二级指针的地址，那么可以说三级指针指向二级指针
  - 多级指针用处多多， 这里暂不举例详细说明。

个人认为指针可以说是 C 的最伟大的特性，通过这样的一个模型可以形象地管理部分内存！


***

##

#### 返回 [C基础知识](../C基础知识.md)