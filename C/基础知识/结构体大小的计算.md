## 结构体大小的计算
#### 返回 [C基础知识](../C基础知识.md)


***


用最简单的方法，通俗易懂的方法计算结构体大小。  
**结构体计算要遵循字节对齐原则。**  
结构体默认的字节对齐一般满足三个准则：  
1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）

> **其实暂且不管这三原则，我的方法只要记住第三个，就是结构体大小结果要为成员中最大字节的整数倍。**

先看下面定义的两个结构体：  
```
struct { char a; short b; char c; }S1;
struct { char a; char b; short c; }S2;
```
分别用程序测试得出 sizeof(S1)=6 , sizeof(S2)=4。  
注意： 为什么 仅仅改变了结构体成员的顺序，结果不一样？  
解：
- （1）首先找出成员变量中最大的字节，可见对于 S1 和 S2 最大是 short ，占 2 个字节；
- （2）所以以后都已2个字节为准，也就是说最多只要2个字节，其他填充占位，注意下图一个格子表示一个字节；
- （3）所以先画2个格子，以后看成员顺序，逐次增加，每次一2为增加基准

对于 S1 来说，顺序是 `char->short->char` :  
![](https://www.runoob.com/wp-content/uploads/2019/05/8DA2FF64-8FFA-4012-967D-5DB63FB284F5.jpg)  
所以对于 S1 结构体大小为 2*3=6，至于为什么第二个 char，多的那个字节不丢到，就是遵循第三个原则，就是结构体大小结果要为成员中最大字节的整数倍。  
```
S1=2*3=6
```
对于 S2 嘛，也画个图，但是顺序是 `char->char->short` ：  
![](https://www.runoob.com/wp-content/uploads/2019/05/E5BA4CAD-6CB1-4B4C-ABAE-8AAC0437D7DB.jpg)  
```
S2=2*2=4
```
按照这个方法再看这样的一个结构体：
```
struct stu1
{
    int i;
    char c;
    int j;
};
```
很明显，最大字节为 4 个。顺序 int char int。  
因为 int 占 4 个，而 char 已经占了一个，不够，所以那三个只能多余占位。  
```
Stu1=3*4=12
```
那么换一下呢？
```
struct stu2
{
    int i;
    int j;
    char  c；
};
```
```
Stu2=3*4=12
```
再看一个：就是当结构体成员变量是另外一个结构体时，只要把结构体中成员为另一结构体作为整体相加就行。  
```
typedef struct A
{
    char a1;
    short int a2;
    int a3;
    double d;
};

A=16

typedef struct B
{
    long int b2;
    short int b1;
    A a;
};
```
而对于 B，先不要管 A a，也就是先去掉 A a 成员结构体 B 算出其为 8，所以最后结果为 8+16=24；24 才是最后结果。

> 原文地址：https://www.cnblogs.com/lykbk/archive/2013/04/02/krtmbhrkhoirtj9468945.html




## 读者笔记


***


第三条有误，"就是结构体大小结果要为成员中最大字节的整数倍。"  
正确来说，若没有设定对齐字节数，则最大成员为对齐字节数。  
若有设定对齐字节数，则对齐字节数为 ：min(最大成员，设定的对齐字节数)。  
> 参考文章：https://zhuanlan.zhihu.com/p/30007037


***


##
#### 返回 [C基础知识](../C基础知识.md)