import{_ as a,o as s,c as n,Q as l}from"./chunks/framework.aaef0e9b.js";const u=JSON.parse('{"title":"2020年PHP面试问题","description":"","frontmatter":{},"headers":[],"relativePath":"问答/PHP/2020年PHP面试问题.md","lastUpdated":1683280071000}'),e={name:"问答/PHP/2020年PHP面试问题.md"},p=l(`<h1 id="_2020年php面试问题" tabindex="-1">2020年PHP面试问题 <a class="header-anchor" href="#_2020年php面试问题" aria-label="Permalink to &quot;2020年PHP面试问题&quot;">​</a></h1><p>原文：<a href="https://zhuanlan.zhihu.com/p/145553170" target="_blank" rel="noreferrer">面试10家公司，收获9个offer，2020年PHP 面试问题</a></p><blockquote><p>近期做了一次工作变动，在职交接近一个半月时间大概面试了十家公司，并且得到了自己比较满意的offer，基本上无缝衔接了新工作。<br> 总体来说，虽然准备的很充分，但面试期间还是暴露了许多问题，在此做下总结，供大家和自己以后参考，主要分四部分讲述：<br> 简历方面：包括七个板块；个人简介，求职意向，工作经历，项目经历，技能描述，学历背景，自我评价。如果自己或公司没有其他要求，这些就够了。</p></blockquote><h2 id="总结几个要素" tabindex="-1">总结几个要素 <a class="header-anchor" href="#总结几个要素" aria-label="Permalink to &quot;总结几个要素&quot;">​</a></h2><ul><li>个人简介 <ul><li>名字大写，内容尽量详实。一是更能给人留下印象，二是减少与面试官交换个人信息的时间，另外更详实的内容能传递更多信息，有更大几率能引起面试官的注意。</li><li>准备一份好的口头自我介绍是很有必要的，毕竟准备一次能用很久，时间花在上面很实用，面外企英文版的最好也提前准备下。</li></ul></li><li>期望薪资*<br> 简历上不要写上期望薪资，能够根据面试情况变化是最好的，如果写，建议高于自身期望，详细参考锚定效应[1]。</li><li>简历排版<br> 简历要尽量简洁，最好不要超过两页。</li><li>项目经历*<br> 项目经历要突出重点*精彩部分（可以具体到某次解决线上问题，某次优化效率提升），2到3个为宜，不重要的可以放在工作经历中一笔带过。<br> 这样有个好处，即面试官根据项目问的问题就会更容易集中在你的经验范围内，在你的预料之中；相应的，如果夸夸其谈，那面试官发挥的面就会更广，你很容易被带着走。</li><li>补充<br> 很多人不重视个人评价栏目，我的技巧是评价最后中带上自己的博客，个人项目，因为在尾部还是很容易被看到并当做加分项的。</li><li>面试流程<br> 流程其实每个公司大同小异，电话面试，笔试，技术面（可能两面），Hr面，部门经理面，可能不同公司有稍微做调整。</li></ul><h2 id="这里需要强调两点" tabindex="-1">这里需要强调两点： <a class="header-anchor" href="#这里需要强调两点" aria-label="Permalink to &quot;这里需要强调两点：&quot;">​</a></h2><ul><li>电话面试：很多大公司都会有电话面试，有些朋友接到面试不管当前情况如何，环境如何都会争取这个机会。而我想说的是，如果身边环境尚可还好，但是如果身处闹市，或者下班回家地铁上信号不好，又或者自己完全没有准备，建议以正当的理由回应面试官 改约其他时间。 这么做好处显而易见：一是减少环境影响，二是自己有更多准备。</li><li>抓住机会问问题：如果对技术有追求一定要向技术官问清楚项目所使用技术，问开发人员上下班时间。向HR问清楚公司的薪酬福利体系，利于自己开价。向管理层问清楚项目目前所处的阶段，以及规划方向。</li></ul><p>最后是面试题概览，基本上汇总了这次面试中遇到的所有问题，中间也有一些是自己当时没有答上来的，这里只做罗列：</p><h2 id="_1-get-post-的区别" tabindex="-1">1.get,post 的区别 <a class="header-anchor" href="#_1-get-post-的区别" aria-label="Permalink to &quot;1.get,post 的区别&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">1、GET在浏览器回退时是无害的，而POST会再次提交请求。</span></span>
<span class="line"><span style="color:#babed8;">2、GET产生的URL地址可以被Bookmark，而POST不可以。</span></span>
<span class="line"><span style="color:#babed8;">3、GET请求会被浏览器主动cache，而POST不会，除非手动设置。</span></span>
<span class="line"><span style="color:#babed8;">4、GET请求只能进行url编码，而POST支持多种编码方式。</span></span>
<span class="line"><span style="color:#babed8;">5、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</span></span>
<span class="line"><span style="color:#babed8;">6、GET请求在URL中传送的参数是有长度限制的，而POST没有。</span></span>
<span class="line"><span style="color:#babed8;">7、对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</span></span>
<span class="line"><span style="color:#babed8;">8、GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</span></span>
<span class="line"><span style="color:#babed8;">9、GET参数通过URL传递，POST放在Request body中。</span></span>
<span class="line"><span style="color:#babed8;">10、GET产生一个TCP数据包，POST产生两个TCP数据包</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="_2-require-include-区别" tabindex="-1">2.require,include 区别 <a class="header-anchor" href="#_2-require-include-区别" aria-label="Permalink to &quot;2.require,include 区别&quot;">​</a></h2><p>require是无条件包含，也就是如果一个流程里加入require,无论条件成立与否都会先执行require<br> include有返回值，而require没有(可能因为如此，require的速度比include快)<br> 包含文件不存在或者语法错误的时候，require是致命的错误，终止执行,include不是</p><h2 id="_3-php-的垃圾回收机制" tabindex="-1">3.PHP 的垃圾回收机制 <a class="header-anchor" href="#_3-php-的垃圾回收机制" aria-label="Permalink to &quot;3.PHP 的垃圾回收机制&quot;">​</a></h2><p>PHP 可以自动进行内存管理，清除不需要的对象。</p><p>PHP 使用了引用计数 (reference counting) GC 机制。</p><p>每个对象都内含一个引用计数器 refcount，每个 reference 连接到对象，计数器加 1。当 reference 离开生存空间或被设为 NULL，计数器减 1。当某个对象的引用计数器为零时，PHP 知道你将不再需要使用这个对象，释放其所占的内存空间。</p><h2 id="_4-常见的排序算法" tabindex="-1">4.常见的排序算法 <a class="header-anchor" href="#_4-常见的排序算法" aria-label="Permalink to &quot;4.常见的排序算法&quot;">​</a></h2><ul><li>1.冒泡排序</li></ul><p>思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><p>代码实现：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">$arr=array(1,43,54,62,21,66,32,78,36,76,39);  </span></span>
<span class="line"><span style="color:#babed8;">function bubbleSort($arr)</span></span>
<span class="line"><span style="color:#babed8;">{  </span></span>
<span class="line"><span style="color:#babed8;">  $len=count($arr);</span></span>
<span class="line"><span style="color:#babed8;">  //该层循环控制 需要冒泡的轮数</span></span>
<span class="line"><span style="color:#babed8;">  for($i=0;$i&lt;$len-1;$i++)</span></span>
<span class="line"><span style="color:#babed8;">  { //该层循环用来控制每轮 冒出一个数 需要比较的次数</span></span>
<span class="line"><span style="color:#babed8;">    for($k=0;$k&lt;$len-$i-1;$k++)</span></span>
<span class="line"><span style="color:#babed8;">    {</span></span>
<span class="line"><span style="color:#babed8;">       if($arr[$k]&gt;$arr[$k+1])</span></span>
<span class="line"><span style="color:#babed8;">        {</span></span>
<span class="line"><span style="color:#babed8;">            $tmp=$arr[$k+1];</span></span>
<span class="line"><span style="color:#babed8;">            $arr[$k+1]=$arr[$k];</span></span>
<span class="line"><span style="color:#babed8;">            $arr[$k]=$tmp;</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span>
<span class="line"><span style="color:#babed8;">  return $arr;</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><ul><li>2.选择排序</li></ul><p>思路分析：在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p><p>代码实现：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">function selectSort($arr) {</span></span>
<span class="line"><span style="color:#babed8;">//双重循环完成，外层控制轮数，内层控制比较次数</span></span>
<span class="line"><span style="color:#babed8;"> $len=count($arr);</span></span>
<span class="line"><span style="color:#babed8;">    for($i=0; $i&lt;$len-1; $i++) {</span></span>
<span class="line"><span style="color:#babed8;">        //先假设最小的值的位置</span></span>
<span class="line"><span style="color:#babed8;">        $p = $i;</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">        for($j=$i+1; $j&lt;$len; $j++) {</span></span>
<span class="line"><span style="color:#babed8;">            //$arr[$p] 是当前已知的最小值</span></span>
<span class="line"><span style="color:#babed8;">            if($arr[$p] &gt; $arr[$j]) {</span></span>
<span class="line"><span style="color:#babed8;">            //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。</span></span>
<span class="line"><span style="color:#babed8;">                $p = $j;</span></span>
<span class="line"><span style="color:#babed8;">            }</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">        //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。</span></span>
<span class="line"><span style="color:#babed8;">        if($p != $i) {</span></span>
<span class="line"><span style="color:#babed8;">            $tmp = $arr[$p];</span></span>
<span class="line"><span style="color:#babed8;">            $arr[$p] = $arr[$i];</span></span>
<span class="line"><span style="color:#babed8;">            $arr[$i] = $tmp;</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">    //返回最终结果</span></span>
<span class="line"><span style="color:#babed8;">    return $arr;</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><ul><li>3.插入排序</li></ul><p>思路分析：在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p><p>代码实现：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">function insertSort($arr) {</span></span>
<span class="line"><span style="color:#babed8;">    $len=count($arr); </span></span>
<span class="line"><span style="color:#babed8;">    for($i=1, $i&lt;$len; $i++) {</span></span>
<span class="line"><span style="color:#babed8;">        $tmp = $arr[$i];</span></span>
<span class="line"><span style="color:#babed8;">        //内层循环控制，比较并插入</span></span>
<span class="line"><span style="color:#babed8;">        for($j=$i-1;$j&gt;=0;$j--) {</span></span>
<span class="line"><span style="color:#babed8;">            if($tmp &lt; $arr[$j]) {</span></span>
<span class="line"><span style="color:#babed8;">                //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span></span>
<span class="line"><span style="color:#babed8;">                $arr[$j+1] = $arr[$j];</span></span>
<span class="line"><span style="color:#babed8;">                $arr[$j] = $tmp;</span></span>
<span class="line"><span style="color:#babed8;">            } else {</span></span>
<span class="line"><span style="color:#babed8;">                //如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。</span></span>
<span class="line"><span style="color:#babed8;">                break;</span></span>
<span class="line"><span style="color:#babed8;">            }</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">    return $arr;</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><ul><li>4.快速排序</li></ul><p>思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p><p>代码实现：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">function quickSort($arr) {</span></span>
<span class="line"><span style="color:#babed8;">    //先判断是否需要继续进行</span></span>
<span class="line"><span style="color:#babed8;">    $length = count($arr);</span></span>
<span class="line"><span style="color:#babed8;">    if($length &lt;= 1) {</span></span>
<span class="line"><span style="color:#babed8;">        return $arr;</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">    //选择第一个元素作为基准</span></span>
<span class="line"><span style="color:#babed8;">    $base_num = $arr[0];</span></span>
<span class="line"><span style="color:#babed8;">    //遍历除了标尺外的所有元素，按照大小关系放入两个数组内</span></span>
<span class="line"><span style="color:#babed8;">    //初始化两个数组</span></span>
<span class="line"><span style="color:#babed8;">    $left_array = array();  //小于基准的</span></span>
<span class="line"><span style="color:#babed8;">    $right_array = array();  //大于基准的</span></span>
<span class="line"><span style="color:#babed8;">    for($i=1; $i&lt;$length; $i++) {</span></span>
<span class="line"><span style="color:#babed8;">        if($base_num &gt; $arr[$i]) {</span></span>
<span class="line"><span style="color:#babed8;">            //放入左边数组</span></span>
<span class="line"><span style="color:#babed8;">            $left_array[] = $arr[$i];</span></span>
<span class="line"><span style="color:#babed8;">        } else {</span></span>
<span class="line"><span style="color:#babed8;">            //放入右边</span></span>
<span class="line"><span style="color:#babed8;">            $right_array[] = $arr[$i];</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">    //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数</span></span>
<span class="line"><span style="color:#babed8;">    $left_array = quick_sort($left_array);</span></span>
<span class="line"><span style="color:#babed8;">    $right_array = quick_sort($right_array);</span></span>
<span class="line"><span style="color:#babed8;">    //合并</span></span>
<span class="line"><span style="color:#babed8;">    return array_merge($left_array, array($base_num), $right_array);</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="_5、给出一个字符串-返回里面连续字母的个数-比如-abbcddde-返回-1a2b1c3de" tabindex="-1">5、给出一个字符串，返回里面连续字母的个数，比如：abbcddde,返回 1a2b1c3de; <a class="header-anchor" href="#_5、给出一个字符串-返回里面连续字母的个数-比如-abbcddde-返回-1a2b1c3de" aria-label="Permalink to &quot;5、给出一个字符串，返回里面连续字母的个数，比如：abbcddde,返回 1a2b1c3de;&quot;">​</a></h2><p>代码实现：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"> public function str($str)</span></span>
<span class="line"><span style="color:#babed8;">{</span></span>
<span class="line"><span style="color:#babed8;">    $re = &#39;&#39;;</span></span>
<span class="line"><span style="color:#babed8;">    $arr = str_split($str);//把字符串变成数组，开始我想到的是用for循环来处理，这个函数同事提醒了才发现</span></span>
<span class="line"><span style="color:#babed8;">    $key = 0; //key 用来记录下标，为了方便计算前面的数字</span></span>
<span class="line"><span style="color:#babed8;">    for ($i = 0; $i &lt; count($arr); $i++) {</span></span>
<span class="line"><span style="color:#babed8;">        $v = $arr[$i];</span></span>
<span class="line"><span style="color:#babed8;">        if ($arr[$i] == $arr[$i + 1]) {</span></span>
<span class="line"><span style="color:#babed8;">            continue;//如果当前的值和下一个值相等，跳出当前循环，进入下一个</span></span>
<span class="line"><span style="color:#babed8;">        } else {</span></span>
<span class="line"><span style="color:#babed8;">            $re  .= ($i - $key + 1) . $v; //不相等时计算出前面的数字，</span></span>
<span class="line"><span style="color:#babed8;">            $key = $i + 1;// 同时 key 下标重新复制</span></span>
<span class="line"><span style="color:#babed8;">        }</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">    return $re;</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="_6、约瑟夫环问题-猴子选大王" tabindex="-1">6、约瑟夫环问题，猴子选大王 <a class="header-anchor" href="#_6、约瑟夫环问题-猴子选大王" aria-label="Permalink to &quot;6、约瑟夫环问题，猴子选大王&quot;">​</a></h2><p>一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">unction mk($n ,$m){</span></span>
<span class="line"><span style="color:#babed8;">    $arr = range(1,$n);//构造一个数组</span></span>
<span class="line"><span style="color:#babed8;">    $i = 1; //从第一个开始循环</span></span>
<span class="line"><span style="color:#babed8;">    while(count($arr)&gt;1){ //如果总数大于1</span></span>
<span class="line"><span style="color:#babed8;">        ($i % $m != 0) &amp;&amp; array_push($arr,$arr[$i-1]);//不被踢出则压入数组尾部</span></span>
<span class="line"><span style="color:#babed8;">        unset($arr[$i-1]);//压入数组然后删除</span></span>
<span class="line"><span style="color:#babed8;">        $i++;//继续循环</span></span>
<span class="line"><span style="color:#babed8;">    }  </span></span>
<span class="line"><span style="color:#babed8;">    return $arr[$i-1]; //直至最后剩下一个为大王 </span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;">print_r(mk(6,8));   //第3只为大王</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="一-什么是-cgi-什么是-fastcgi-php-fpm-fastcgi-nginx-之间是什么关系" tabindex="-1">一.什么是 CGI？什么是 FastCGI？php-fpm，FastCGI，Nginx 之间是什么关系？ <a class="header-anchor" href="#一-什么是-cgi-什么是-fastcgi-php-fpm-fastcgi-nginx-之间是什么关系" aria-label="Permalink to &quot;一.什么是 CGI？什么是 FastCGI？php-fpm，FastCGI，Nginx 之间是什么关系？&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">CGI，通用网关接口，用于WEB服务器和应用程序间的交互，定义输入输出规范，用户的请求通过WEB服务器转发给FastCGI进程，FastCGI进程再调用应用程序进行处理，如php解析器，应用程序的处理结果如html返回给FastCGI，FastCGI返回给Nginx 进行输出。假设这里WEB服务器是Nginx，应用程序是 PHP，而 php-fpm 是管理 FastCGI 的，这也就是 php-fpm，FastCGI，和 Nginx 之间的关系。</span></span>
<span class="line"><span style="color:#babed8;">FastCGI 用来提高 cgi 程序性能，启动一个master，再启动多个 worker，不需要每次解析 php.ini. 而 php-fpm 实现了 FastCGI 协议，是 FastCGI 的进程管理器，支持平滑重启，可以启动的时候预先生成多个进程。</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="二-memcache-和-redis-的区别" tabindex="-1">二.memcache 和 Redis 的区别 <a class="header-anchor" href="#二-memcache-和-redis-的区别" aria-label="Permalink to &quot;二.memcache 和 Redis 的区别&quot;">​</a></h2><ul><li>数据结构：memcache仅支持简单的key-value形式，Redis支持的数据更多（string字符串，set集合，list列表，hash散列，zset有序集合）；</li><li>多线程：memcache支持多线程，Redis支持单线程</li><li>持久化：Redis支持持久化，memcache不支持持久化</li><li>分布式：Redis做主从结构，memcache服务器需要通过hash一致化来支撑主从结构</li></ul><p>实际运用中可以redis，memcache结合，memcache可作为session存储的方式，session都是KV类型键值对。</p><ol><li>Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别。</li><li>Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcache只是简单的K/V缓存。</li><li>他们的扩展都需要做集群；实现方式：master-slave、Hash。</li><li>在100k以上的数据中，Memcache性能要高于Redis。</li><li>如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。</li><li>如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcache都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。</li><li>Redis和Memcache在写入性能上面差别不大，读取性能上面尤其是批量读取性能上面Memcache更强</li><li>Redis 提供了多种不同级别的持久化方式：<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</span></span>
<span class="line"><span style="color:#babed8;">AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</span></span>
<span class="line"><span style="color:#babed8;">Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</span></span>
<span class="line"><span style="color:#babed8;">你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div></li></ol><h2 id="三-什么是-redis-穿透和雪崩" tabindex="-1">三.什么是 Redis 穿透和雪崩 <a class="header-anchor" href="#三-什么是-redis-穿透和雪崩" aria-label="Permalink to &quot;三.什么是 Redis 穿透和雪崩&quot;">​</a></h2><ul><li>缓存穿透</li></ul><p>当访问redis中一个不存在的key的时候,会直接穿过缓存,去数据库中进行查询.</p><p>如果是黑客,进行恶意攻击的时候,每次都请求超过2000个/秒的时候,这个时候mysql基本上就挂了.</p><p>解决办法是：每次从数据库中查询到一个不存在的key的时候,就写一个空值到缓存库中,有恶意攻击的时候,直接从缓存中取到这个空值.</p><ul><li>缓存雪崩</li></ul><p>假设每秒有5000个请求过来时候,redis缓存库崩了,然后这些请求瞬间落在了mysql数据库上,直接导致数据库死机.</p><p>解决方案就是:</p><ul><li>事前：提高缓存库的高可用, 使用主从结构加哨兵 cluster集群</li><li>事中：使用ehcache+hystrix限流组件(当请求量非常巨大的时候,就调用自己开发好的一个降级饿组件,返回一些默认值,如友情提示,或者空白值)</li><li>事后：做持久化,尽快恢复缓存集群,一旦恢复,自动从磁盘上读取数据,恢复内存中的数据。</li></ul><h2 id="四-redis-消息队列先进先出需要注意什么" tabindex="-1">四.redis 消息队列先进先出需要注意什么？ <a class="header-anchor" href="#四-redis-消息队列先进先出需要注意什么" aria-label="Permalink to &quot;四.redis 消息队列先进先出需要注意什么？&quot;">​</a></h2><p>通常使用一个list来实现队列操作，这样有一个小限制，所有的任务统一都是先进先出，如果想优先处理某个任务就不太好处理了，这就需要让队列有优先级的概念，我们就可以优先处理高级别的任务，实现方式有以下几种方式：</p><ul><li>单一列表实现：队列正常的操作是 左进右出（lpush,rpop）为了先处理高优先级任务，在遇到高级别任务时，可以直接插队，直接放入队列头部（rpush），这样，从队列头部（右侧）获取任务时，取到的就是高优先级的任务（rpop）</li><li>使用两个队列，一个普通队列，一个高级队列，针对任务的级别放入不同的队列，获取任务时也很简单，redis的BRPOP命令可以按顺序从多个队列中取值，BRPOP会按照给出的 key 顺序查看，并在找到的第一个非空 list 的尾部弹出一个元素，</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">redis&gt; BRPOP list1 list2 0</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">list1 做为高优先级任务队列</span></span>
<span class="line"><span style="color:#babed8;">list2 做为普通任务队列</span></span>
<span class="line"><span style="color:#babed8;">这样就实现了先处理高优先级任务，当没有高优先级任务时，就去获取普通任务</span></span>
<span class="line"><span style="color:#babed8;">方式1最简单，但实际应用比较局限，方式3可以实现复杂优先级，但实现比较复杂，不利于维护</span></span>
<span class="line"><span style="color:#babed8;">方式2是推荐用法，实际应用最为合适</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre></div><h2 id="五-redis-如何防止高并发" tabindex="-1">五.Redis 如何防止高并发？ <a class="header-anchor" href="#五-redis-如何防止高并发" aria-label="Permalink to &quot;五.Redis 如何防止高并发？&quot;">​</a></h2><p>其实redis是不会存在并发问题的，因为他是单进程的，再多的命令都是一个接一个地执行的。我们使用的时候，之所以可能会出现并发问题，比如获得和设定这一对。</p><ul><li>Redis的为什么会有高并发问题？</li></ul><p>【Redis的的出身决定】</p><p>Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对redis进行并发访问时会出现问题。发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p><p>同时，单线程的天性决定，高并发对同一个键的操作会排队处理，如果并发量很大，可能造成后来的请求超时。<br> 在远程访问redis的时候，因为网络等原因造成高并发访问延迟返回的问题。</p><ul><li>解决办法</li></ul><p>在客户端将连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度，利用setnx变向实现锁机制。</p><h2 id="六-说说对-sql-语句优化有哪些方法" tabindex="-1">六.说说对 SQL 语句优化有哪些方法？ <a class="header-anchor" href="#六-说说对-sql-语句优化有哪些方法" aria-label="Permalink to &quot;六.说说对 SQL 语句优化有哪些方法？&quot;">​</a></h2><ol><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</li><li>避免在索引列上使用计算</li><li>避免在索引列上使用IS NULL和IS NOT NULL</li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li></ol><h2 id="一-数据库三范式" tabindex="-1">一.数据库三范式 <a class="header-anchor" href="#一-数据库三范式" aria-label="Permalink to &quot;一.数据库三范式&quot;">​</a></h2><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br> 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br> 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p><p>范式化设计优缺点:</p><ul><li>优点: 可以尽量得减少数据冗余，使得更新快，体积小</li><li>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</li></ul><p>反范式化:</p><ul><li>优点:可以减少表得关联，可以更好得进行索引优化</li><li>缺点:数据冗余以及数据异常，数据得修改需要更多的成本</li></ul><h2 id="二-mysql-中有哪几种锁" tabindex="-1">二.Mysql 中有哪几种锁 <a class="header-anchor" href="#二-mysql-中有哪几种锁" aria-label="Permalink to &quot;二.Mysql 中有哪几种锁&quot;">​</a></h2><ul><li>MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁</li><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</li><li>行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高</li></ul><h2 id="三-什么是存储过程" tabindex="-1">三.什么是存储过程 <a class="header-anchor" href="#三-什么是存储过程" aria-label="Permalink to &quot;三.什么是存储过程&quot;">​</a></h2><p>我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。</p><p>优点：</p><ol><li>存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li><li>存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li><li>存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</li><li>存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。</li><li>存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</li></ol><h2 id="四-如何处理负载、高并发" tabindex="-1">四.如何处理负载、高并发 <a class="header-anchor" href="#四-如何处理负载、高并发" aria-label="Permalink to &quot;四.如何处理负载、高并发&quot;">​</a></h2><ul><li>1、HTML静态化</li></ul><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。</p><ul><li>2、图片服务器分离</li></ul><p>把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等。</p><ul><li>3、数据库集群和库表散列及缓存</li></ul><p>数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。</p><ul><li>4、镜像</li></ul><p>尽量减少下载，可以把不同的请求分发到多个镜像端。</p><ul><li>5、负载均衡：</li></ul><p>Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。</p><p>负载均衡 （Load Balancing） 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件【Nginx】、【LVS】、【HAProxy】。</p><p>我分别来说下三种的优缺点:</p><h3 id="【nginx】" tabindex="-1">【Nginx】 <a class="header-anchor" href="#【nginx】" aria-label="Permalink to &quot;【Nginx】&quot;">​</a></h3><h4 id="nginx的优点是" tabindex="-1">Nginx的优点是： <a class="header-anchor" href="#nginx的优点是" aria-label="Permalink to &quot;Nginx的优点是：&quot;">​</a></h4><ul><li>工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。</li><li>Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大，这点本人深有体会；</li><li>Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。</li><li>可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。</li><li>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。</li><li>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。</li><li>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。</li><li>Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有 lighttpd了，不过 lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。</li><li>Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</li></ul><h4 id="nginx的缺点是" tabindex="-1">Nginx的缺点是： <a class="header-anchor" href="#nginx的缺点是" aria-label="Permalink to &quot;Nginx的缺点是：&quot;">​</a></h4><ul><li>Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。</li><li>对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</li></ul><h3 id="【lvs】" tabindex="-1">【LVS】 <a class="header-anchor" href="#【lvs】" aria-label="Permalink to &quot;【LVS】&quot;">​</a></h3><p>使用Linux内核集群实现高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</p><h4 id="lvs的优点是" tabindex="-1">LVS的优点是： <a class="header-anchor" href="#lvs的优点是" aria-label="Permalink to &quot;LVS的优点是：&quot;">​</a></h4><ul><li>抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li><li>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。</li><li>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。</li><li>无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会受到大流量的影响。</li><li>应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li></ul><h4 id="lvs的缺点是" tabindex="-1">LVS的缺点是： <a class="header-anchor" href="#lvs的缺点是" aria-label="Permalink to &quot;LVS的缺点是：&quot;">​</a></h4><ul><li>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。</li><li>如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有 Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</li></ul><h3 id="【haproxy】" tabindex="-1">【HAProxy】 <a class="header-anchor" href="#【haproxy】" aria-label="Permalink to &quot;【HAProxy】&quot;">​</a></h3><h4 id="haproxy的特点是" tabindex="-1">HAProxy的特点是： <a class="header-anchor" href="#haproxy的特点是" aria-label="Permalink to &quot;HAProxy的特点是：&quot;">​</a></h4><ul><li>HAProxy也是支持虚拟主机的。</li><li>HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。</li><li>HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。</li><li>HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。</li></ul><h4 id="haproxy负载均衡策略非常多-haproxy的负载均衡算法现在具体有如下8种" tabindex="-1">HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种： <a class="header-anchor" href="#haproxy负载均衡策略非常多-haproxy的负载均衡算法现在具体有如下8种" aria-label="Permalink to &quot;HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：&quot;">​</a></h4><ol><li>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；</li><li>② static-rr，表示根据权重，建议关注；</li><li>③ leastconn，表示最少连接者先处理，建议关注；</li><li>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；</li><li>⑤ ri，表示根据请求的URI；</li><li>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；</li><li>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；</li><li>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</li></ol><h3 id="nginx和lvs对比的总结" tabindex="-1">Nginx和LVS对比的总结： <a class="header-anchor" href="#nginx和lvs对比的总结" aria-label="Permalink to &quot;Nginx和LVS对比的总结：&quot;">​</a></h3><ol><li>Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。</li><li>Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。</li><li>Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。</li><li>Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。</li><li>Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。</li><li>Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用 apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。</li><li>Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</li></ol>`,113),i=[p];function r(o,c,t,b,d,h){return s(),n("div",null,i)}const $=a(e,[["render",r]]);export{u as __pageData,$ as default};
